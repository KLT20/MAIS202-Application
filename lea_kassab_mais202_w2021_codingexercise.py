# -*- coding: utf-8 -*-
"""Lea_Kassab_MAIS202_W2021_CodingExercise.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xKapt1UVR0o_qwz-kJTIiWE-pL-4Vawz

# MAIS 202 Winter 2021 Coding Exercise

[Application](https://tiny.cc/mais202-w2021-app)

[Course Syllabus](http://tiny.cc/mais202-w2021-syllabus)

## Instructions
 Make a copy of this notebook into your personal Google Drive account and
**make sure that this is notebook public** by 11:59 pm, January 15th, 2021 in order to be evaluated. **Kindly attempt all 3 questions.**

If you have any questions regarding this challenge, please check out our [syllabus + FAQ](https://docs.google.com/document/d/1RflGt9NnGwW1dhmg6VeuRQBy07qF_SUXpwKOEJ9VAEw/edit?usp=sharing), or reach out to us through our [Facebook Page](https://www.facebook.com/McGillAI/).

## Questions
* [Part 1](#scrollTo=QYskRrWJEwZH)
* [Part 2 Task 1](#scrollTo=yl9IKD31K-J0)
* [Part 2 Task 2](#scrollTo=t_xY3228qPmP)

## Part 1

This part asks you to analyze a dataset using libraries.
To learn more about movies grosses, we have provided you with two csv's: `movies_data.csv` and `genre_data.csv`.
The urls to the files are
```
https://raw.githubusercontent.com/williamykzhang/MAIS_CE/master/genre_data.csv
```
and
```
https://raw.githubusercontent.com/williamykzhang/MAIS_CE/master/movies_data.csv
```
The file `movies_data.csv` contains information about movies such as their title, imdb rating, length, rank, rating, studio, worldwide gross, and year in a comma seperated format as shown below.
![CSV example 1](https://user-images.githubusercontent.com/10730760/71313653-b9478880-2409-11ea-8745-a58909dcbd0f.png)

The file `genre_data.csv` contains the genre for each movie in the `movies_data.csv` file, as shown below.
![CSV example 2](https://user-images.githubusercontent.com/10730760/71313662-d3816680-2409-11ea-94c7-6795663ef8e3.png)

Your challenge is as follows:

1. In the provided cell, load the datasets from their urls, parse the information and determine the average worldwide gross for each of the genres using the **pandas** library. https://pandas.pydata.org/.
2. Plot the results onto a graph using the pyplot module of the **matplotlib** library. https://matplotlib.org/.

**Note.** You are not allowed to use other libraries, and you are required to write all the code in the following cell. You are also not allowed to run bash commands. You must use the libraries we ask you to use.
"""

#Lea Kassab ID:260784886
import pandas as pd
import matplotlib.pyplot as plt
#read the data in each of the urls 
movie_url = "https://raw.githubusercontent.com/williamykzhang/MAIS_CE/master/movies_data.csv"
genre_url = "https://raw.githubusercontent.com/williamykzhang/MAIS_CE/master/genre_data.csv"

#load datasets
movies = pd.read_csv(movie_url)
genres = pd.read_csv(genre_url)

#join the two tables so that genre and gross are in the same dataframe
genres_gross = pd.merge(genres, movies, how="left", on="title")
genres_gross.head()

#reduce the table to only essential data
cleaned = genres_gross.drop(columns=['title','imdb_rating', 'length', 'rank_in_year', 'rating', 'studio', 'year'])
genres_list = ['Action','Adventure','Animation','Comedy','Crime','Drama','Family','Fantasy','History','Horror','Music','Romance','Sci-Fi','Sport','Thriller','War']

results = [] #empty list to fill with each genres' worlwide_gross
for genre in genres_list:    #loop to repeat for all genres
    price = cleaned.loc[cleaned["Main_Genre"] == genre].copy(deep=True) #create new df with movies from the same genre
    price["worldwide_gross"] = price["worldwide_gross"].str.replace(',', '').copy(deep=True) #remove the , to convert to float
    price["worldwide_gross"] = price["worldwide_gross"].str.replace('$', '').copy(deep=True) #remove the $ to convert to float
    price["worldwide_gross"] = price["worldwide_gross"].astype(float).copy(deep=True)
    gross = price["worldwide_gross"].copy(deep=True)
    results.append(gross.sum()/gross.size) #compute average
    
#convert dictionary to dataframe
data = {'Main_Genre': genres_list, 'worldwide_gross': results}
data_table = pd.DataFrame.from_dict(data)
data_table


# !! RUN NEXT CELL TO SEE PLOT !!

#plot the table
#plt.bar(genres_list, results)
#plt.ylabel('Worldwide_gross')
#plt.xlabel('Main_Genre')
#plt.title('Average worldwide gross')
#plt.show()

import matplotlib.pyplot as plt
#plot the table
plt.bar(genres_list, results)
plt.ylabel('Worldwide_gross')
plt.xlabel('Main_Genre')
plt.title('Average worldwide gross')
plt.show()

"""The output of the cell should be similar to the results shown below.


![results1](https://raw.githubusercontent.com/williamykzhang/MAIS_CE/master/picture_2.png)
![results2](https://raw.githubusercontent.com/williamykzhang/MAIS_CE/master/picture_3.png)

## Part 2

For the second half of the coding challenge, you are not allowed to use libraries.
More specifically, you are not allowed to use imported code from the standard library nor from external libraries.

### First Task

Your first task is to write a helper function `to_grade_point` which converts a grade out of 100 into a `tuple` whose first entry is a string representing the letter grade and whose second entry is a float representing the Grade Points.


![Letter Grade Table](https://i.ibb.co/WnvbXL1/table.png)


**Note.** Inputs are assumed to be valid. That is, inputs will be integers from 0 to 100 inclusive.
"""

# Lea Kassab ID:260784886

Letter_grade = ['A','A-','B+','B','B-','C+','F'] 
Grade_points = [4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 0.0]

def to_grade_point(grade):

  if 80 <= grade <= 100:
    if grade < 85:
      i = 1
    else:i = 0

  if 65 <= grade <= 79:
    if grade < 70:
      i = 4
    if grade < 75:
      i = 3
    else: i = 2

  if grade <= 64:
    if grade < 60:
      i = 6
    else: i = 5
  grade_tuple = (Letter_grade[i], Grade_points[i])
  return(grade_tuple)

"""You can test your code with the following snippet.
If your code is correct, you should see

![Example Code 1](https://i.ibb.co/4F9mP9Y/code1.png)
"""

for grade in [0, 99, 80, 85, 84, 60, 59, 74]:
  print("{} -> {}".format(grade, to_grade_point(grade)))

"""### Second Task

Your second task is to write a class named `GradeRecords` with a certain specification.
This part will use the helper function defined in the first part so make sure to do that first.

A `GradeRecords` object has the following attributes:
* `term`, a string representing the current semester;
* `grades`, a `list` object containing `tuples`, where the first entry of each tuple is a string representing the code of the class, the second entry of each tuple is the grade out of 100, and the third entry is the number of credits for this course. `grades` can be initialized (see below) as an empty list.
* `num_courses` an `int` which contains the number of courses in the record. This can be initialized as 0.


**Note.** You are not allowed to add more attributes.

Furthermore, a `GradeRecords` object has the following methods:
* an initialization method which takes as input the current term and initializes the three attributes;
* `add_course`, a method which takes a string representing the course code, an int for the grade out of 100 and the number of credits. The method adds a new tuple to `grades`.
* `get_best_courses`, a method which takes no parameters and outputs a list of course codes with the best grades. For instance, if the best grade is a 'B', it will output all course codes with a 'B', i.e. all courses codes with a grade between 70 and 74 (inclusive). You are required to use the helper function defined in the first part.
* `get_GPA`, a method which outputs the Grade Point Average for the semester, assuming all classes all weighted by the number of credits. You are required to use the helper function from the first task. Round it to one decimal place.
* `to_dict`, a method which returns a dict whose keys are the class codes and whose corresponding values are the letter grades. Once again, you must use the helper function from the first task.

**Note.** All inputs are assumed to be valid. Particularly, you may assume there won't be duplicate class codes.
"""

# Lea Kassab ID:260784886

grades = []
num_courses = 0
best_list = []
final_list = []
all_grades = []
list_grades_gpa = []
computed = 0
new = []
total = 0
num = 0 
amount_of_courses = []
all_classes = []
all_course_codes = []

class GradeRecords:
  
  def __init__(self, term):
    self.term = term
    self.grades = grades
    self.num_courses = num_courses

  def add_course(self, course_code, course_grade, num_credits):
    self.course_code = course_code
    self.course_grade = course_grade
    self.num_credits = num_credits
    new_tuple = (course_code, course_grade, num_credits)
    self.grades = grades.append(new_tuple)
    self.num_courses = self.num_courses + 1

  def get_best_courses(self): #self is not a parameter taken in, it's refering to the object itself
    for i in range(len(grades)):
      x = 1 #position of the 'grade' for each course in our nested tuple
      grade = grades[i][x] #list of the grades out of 100
      letter_and_points = to_grade_point(grade) #convert to letter and points
      high_class = letter_and_points[1] 
      self.best_list = best_list.append(high_class)
      j = max(best_list) #as
      for k in range(len(grades)):
        if to_grade_point(grades[k][1])[1] == j: #if numerical grade is the same as maximum, add to list
          self.final_list = final_list.append(grades[k][0])
      return(final_list)
      
  def get_GPA(self):
    
    for n in range(len(grades)):
      self.num = num + 1 #keep track of how many classes were computed for the GPA
      self.amount_of_courses = amount_of_courses.append(self.num)
      loops = sum(amount_of_courses)
      
      x = 1 #position of the 'grade' for each course in our nested tuple
      grade_points = grades[n][x] #list of the grades out of 100      
      letter_points = to_grade_point(grade_points) #convert to letter and points
      self.new = new.append(letter_points[1])
      total = sum(new) 
      GPA_decimals = total/loops #compute the GPA by dividing by the amount of courses counted
      GPA = round(GPA_decimals, 1)
    return(GPA)
      
  def to_dict(self):
     #create list of grades to set as values of dict
    for i in range(len(grades)):
      x = 1 #position of the 'grade' for each course in our nested tuple
      the_grades = grades[i][x] #list of the grades out of 100
      letter_then_points = to_grade_point(the_grades) #convert to letter and points
      letter_grades = letter_then_points[0] 
      self.all_classes = all_classes.append(letter_grades) 
      values = all_classes
     #create list of courses to set as keys of dict
    for i in range(len(grades)):
      x = 0 #position of the 'course code' for each course in our nested tuple
      code_of_course = grades[i][x] #list of the course code
      self.all_course_codes = all_course_codes.append(code_of_course) 
      keys = all_course_codes
      #create dict from both keys and values 
    new_dict = dict(zip(keys, values))
    return(new_dict)

"""You can test your code with the following snippet. If your code is correct you should see

![code example 2](https://i.ibb.co/xCPCWyy/code2.png)
"""

gr = GradeRecords("Fall 2019")
print("First batch")
print("Term: {}".format(gr.term))

gr.add_course("COMP 202", 83, 3)
gr.add_course("CLAS 203", 75, 3)
gr.add_course("LING 360", 81, 3)

print("Number of courses: {}".format(gr.num_courses))
print("Best courses: {}".format(gr.get_best_courses()))
print("GPA: {}".format(gr.get_GPA()))
print("Dictionary: {}".format(gr.to_dict()))

print() 

print("Second batch")
print("Term: {}".format(gr.term))

gr.add_course("COMP 551", 67, 4)
gr.add_course("HIST 318", 88, 3)

print("Number of courses: {}".format(gr.num_courses))
print("Best courses: {}".format(gr.get_best_courses()))
print("GPA: {}".format(gr.get_GPA()))
print("Dictionary: {}".format(gr.to_dict()))